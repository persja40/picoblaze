VHDL "ROM_form.vhd", "proj.vhd"
MEM "proj.mem"

leds_0 DSIO $00 ;port ledy

int_mask DSOUT $E1 ;maska przerwan
int_status DSIO $E0 ;status przerwan

ps2_out DSOUT $70 ;port wyjsciowy ps2
ps2 DSIN $70 ;port wejsciowy ps2
ps2_int_edge DSIO $71 ;wybor typu przerwan
ps2_int_value DSIO $72 ;wybor zbocza przerwan
ps2_int_mask DSIO $73 ;maska przerwan

lcd_control DSOUT $31
lcd_value DSOUT $30


LOAD s4, 0 ;dane dotyczace stanu ramki ps/2
LOAD s5, 0 ;czy przycisk jest puszczany

CALL init_lcd

dane:
LOAD s1, 0
LOAD s0, %00000011
OUT s0, leds_0

ustawienieprzerwan:
LOAD s0, %00000010 ;zaladowanie przerwan z ps/2
OUT s0, int_mask

ustawienieczytania:
LOAD s0, %11
OUT s0, ps2_out
LOAD s0, %01 ;zrodlo przerwan z linii ps_clk
OUT s0, ps2_int_mask
LOAD s0, %01 ;zbocze dla ps/2, chyba trzeba zmienic na 00
OUT s0, ps2_int_edge
LOAD s0, %00
OUT s0, ps2_int_value

LOAD s5, 10

CALL opoznij_5ms
CALL opoznij_5ms
CALL opoznij_5ms
CALL opoznij_5ms
LOAD sF, 0
OUT sF, int_status

EINT

koniec:
JUMP koniec

zero: SR0 s1 ;otrzymanie 1 z ps_data
	JUMP dalej

jeden: SR1 s1 ;otrzymanie 0 z ps_data
	JUMP dalej
	
bitstartu: ;obsluga bitu startu
	;TEST s0, %10
	;JUMP Z, bitstartuOk
	;JUMP NZ, koniecint
	JUMP bitstartuOk
	
bitstartuOk:
	JUMP dalej
	
bitstopu: ;obsluga bitu stopu
	;TEST s0, %10
	;JUMP NZ, bitstopuOk
	;JUMP Z, koniecint
	JUMP bitstopuOk
	
bitstopuOk:
	LOAD s4, 0
	OUT s1, leds_0
	;COMP s1, $1C ;scancode litery A
	;JUMP Z, A
	;COMP s1, $32
	;JUMP Z, B
	TEST s5, %1
	JUMP NZ, koniecpuszczania
	COMP s1, $F0 ;jezeli kod F0, to znaczy ze klawisz jest puszczony
	JUMP Z, puszczamy
	COMP s1, $1C ;scancode litery A
	JUMP Z, A
	COMP s1, $32
	JUMP Z, B
	COMP s1, $21
	JUMP Z, CC
	COMP s1, $23
	JUMP Z, D
	COMP s1, $24
	JUMP Z, E
	COMP s1, $2B
	JUMP Z, F
	COMP s1, $34
	JUMP Z, G
	COMP s1, $33
	JUMP Z, H
	COMP s1, $66
	JUMP Z, BACKSPACE
	COMP s1, $29
	JUMP Z, SPACE
	LOAD s6, s1
	JUMP koniecint
	
puszczamy:
	LOAD s5, 1
	JUMP koniecint

wyswietl:
	CALL print_lcd;wyswietlenie rejestru s6 na ekran
	JUMP koniecint
	
A:
	LOAD s6, $41 ;zaladowanie litery A w ascii do rejestru s6
	JUMP wyswietl
	
B:
	LOAD s6, $42
	JUMP wyswietl
	
CC:
	LOAD s6, $43
	JUMP wyswietl
	
D:
	LOAD s6, $44
	JUMP wyswietl
	
E:
	LOAD s6, $45
	JUMP wyswietl
	
F:
	LOAD s6, $46
	JUMP wyswietl
	
G:
	LOAD s6, $47
	JUMP wyswietl
	
H:
	LOAD s6, $48
	JUMP wyswietl

BACKSPACE:
	CALL backspace_lcd
	JUMP koniecint

SPACE:
	LOAD s6, $20
	JUMP wyswietl
	
	
koniecpuszczania:
	LOAD s5, 0
	JUMP koniecint
	
parity: ;obsluga bitu parzystosci
	;TEST s1, $FF
	;JUMP C, parityone
	;JUMP NC, parityzero
	JUMP parityOk
	
parityone:
	TEST s0, %10
	JUMP NZ, parityOk
	JUMP Z, koniecint
	
parityzero:
	TEST s0, %10
	JUMP Z, parityOk
	JUMP NZ, koniecint	

parityOk:
	JUMP dalej

interrupt:

	IN s0, ps2 ;pobranie bitu
	;OUT s4, leds_0
	;ADD s4, 1
	
	COMP s4, 0 ;jezeli to pierwszy bit ramki, to obsluga bitu startu
	JUMP Z, bitstartu
	
	COMP s4, 10 ;jezeli to 11 bit ramki, to obsluga bitu stopu
	JUMP Z, bitstopu
	
	COMP s4, 9 ;jezeli to 10 bit ramki, to obsluga parzystosci
	JUMP Z, parity
	
	;tutaj program dochodzi gdy przesylany jest bit pomiedzy 1,  8 ramki, czyli dane
	TEST s0, %10
	JUMP Z, zero
	JUMP NZ, jeden
	
	dalej:
	ADD s4, 1
	
	koniecint:
	LOAD sF, 0
	OUT sF, int_status
	reti enable

init_lcd:
	LOAD s0, $38


	LOAD sA, %00000000
	LOAD sB, %00000001
	
	OUT s0, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	
	CALL opoznij_5ms
	
	OUT s0, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	
	CALL opoznij_100us
	
	OUT s0, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	
	CALL opoznij_50us
	
	OUT s0, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	
	CALL opoznij_5ms
	
	LOAD s0, $06
	OUT s0, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	
	CALL opoznij_50us
	
	LOAD s0, $0E
	OUT s0, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	
	CALL opoznij_50us
	
	LOAD s0, $01
	OUT s0, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	
	CALL opoznij_5ms
	
	;LOAD s0, $80
	;OUT s0, lcd_value
	;OUT sB, lcd_control
	;CALL NOP
	;OUT sA, lcd_control
	;LOAD s0, $00
	;OUT s0, lcd_value
	;OUT sB, lcd_control
;	CALL NOP
;;	OUT sA, lcd_control
;	CALL opoznij_50us

	LOAD s0, $80
	OUT s0, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	
	CALL opoznij_50us
	
	LOAD sA, %00000010
	LOAD sB, %00000011
	
	CALL opoznij_50us
	LOAD sC, 0
	RET

print_lcd:
	ADD sC, 1

	LOAD sA, %00000000
	LOAD sB, %00000001
	
	COMP sC, 17
	JUMP NZ, end_16
	LOAD sF, $C0
	OUT sF, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	CALL opoznij_50us
	end_16:
	
	COMP sC, 33
	JUMP NZ, end_56
	LOAD sF, $80
	OUT sF, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	CALL opoznij_50us
	LOAD sC, 0
	end_56:

	LOAD sA, %00000010
	LOAD sB, %00000011
	;LOAD s0, $33
	OUT s6, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	
	CALL opoznij_50us
	RET

backspace_lcd:
	CALL cofnij_kursor
	LOAD s6, $20
	CALL print_lcd
	CALL cofnij_kursor
	RET
	
cofnij_kursor:
	LOAD sA, %00000000
	LOAD sB, %00000001
	SUB sC, 1
	LOAD sF, $80
	ADD sF, sC
	OUT sF, lcd_value
	OUT sB, lcd_control
	CALL NOP
	OUT sA, lcd_control
	CALL opoznij_50us
	RET

NOP:
LOAD s0, s0
LOAD s0, s0
LOAD s0, s0
RET

opoznij_1us_const EQU 24
opoznij_1us: LOAD sF, opoznij_1us_const
czekaj: SUB  sF, 01
JUMP NZ, czekaj
RET

opoznij_50us: LOAD sE, 50 ;36d
czekaj_50us: CALL opoznij_1us
SUB  sE,01
JUMP NZ, czekaj_50us
RET

opoznij_100us: LOAD sE, 100 ;36d
czekaj_100us: CALL opoznij_1us
SUB  sE,01
JUMP NZ, czekaj_100us
RET

opoznij_5ms: LOAD sD, 50 ;25d
czekaj_5ms: CALL opoznij_100us
SUB  sD,01
JUMP NZ, czekaj_5ms
RET
	

ORG $3FF
JUMP interrupt
